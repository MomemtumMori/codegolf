{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding ((>>=),concatMap,filter,foldl,head,last,map,null,replicate)
import Control.Applicative hiding (empty)
import Control.Monad hiding (replicateM)
import Data.Vector hiding ((++),concat,foldM,reverse,zip)
main=getLine>>= \s->h$fromList<$>(zip$cycle[False,True])<$>b s>>= \m->foldM(\b(c,x)->case d b x c of r@(Right _)->r;Left _->if not$null$findIndices(\y->e$d b y c)$fromList[(x,y)|x<-[0..7],y<-[0..7]];then Left$"wrong move "++show x++".";else d b x$not c)k$toList m
 where b(x:y:s)=(:)(read [x],read [y])<$>b s;b(_:_)=Left"invalid coordinates string";b[]=Right[];d b z c=let d=join$map(f b z c)$map(\v->(head v,last v))$replicateM 2$fromList[-1,0,1];in if null d;then Left$"impossible move "++show z++".";else foldM(\b (x,y)->case b!?y of Just r->(case r!?x of Just _->Right$b//[(y,r//[(x,Just c)])];Nothing->Left"x is out of bounds");Nothing->Left"y is out of bounds")b$toList$d`snoc`z;e(Left _)=False;e(Right _)=True;f b(x,y)c z@(u,v)=let r=x+u;s=y+v;t=(r,s);in (case g b t of Right(Just d)->if d==c;then empty;else (case g b (r+u,s+v) of Right(Just _)->t`cons`f b t c z;_->empty);Right(Nothing)->empty;Left _->empty);g b(x,y)=(case b!?y of Just col->(case col!?x of Just c->Right c;Nothing->Left"x is out of bounds");Nothing->Left"y is out of bounds");h(Right b)=putStrLn$(concat$toList$map(\r->concat(toList$map(\c->case c of Just False->"░B";Just True->"▓W";Nothing->"██")r)++"\n")b)++(i(foldl(\(w,b)(rw,rb)->(w+rw,b+rb))(0,0)$map(\r->foldl(\s@(w,b)c->case c of Just True->(w+1,b);Just False->(w,b+1);_->s)(0,0)r)b)++"\n");h(Left s)=putStrLn s;i(w,b)|w>b="White with "++show w++" against Black with "++show b++"."|b>w="Black with "++show b++" against White with "++show w++"."|True="Nobody with "++show (w+b)++".";j=replicate 8 Nothing;k=replicate 8 j//[(3,j//[(3,Just True),(4,Just False)]),(4,j//[(3,Just False),(4,Just True)])]
